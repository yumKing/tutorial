git操作：
1、github上创建一个仓库
2、git remote add origin 仓库地址
3、git pull origin master(第一次报错)
	1、fatal: Couldn't find remote ref master 不用管，继续提交
	2、git remote rm origin
	   git remote add origin XXXX
4、git push -u origin master

=======================
git安装配置:

用户配置:
git config --global user.name xxx
git config --global user.email xxx

git config --system --unset credential.helper

文本编辑器配置:(默认不用设置)
git config --global core.editor emacs

差异分析工具配置(默认不用设置)
git config --global merge.tool vimdiff

检查已有的配置信息
git config --list

基本操作:
git init , 在需要把制定项目交由git管理使用，项目根目录使用
git add xxx/all ,将修改的文件或者很多文件添加到缓存区时使用
git commit ,提交修改到本地git仓库
git commit -a,暂存加提交，简化操作
git commit -amend 提交时，将最后一次已提交的记录删除，并生成新的提交版本

git clone [url] [local_prj_name],
url 协议: git://  http(s)://  user@server://path.git
将远程仓库克隆到本地,可以修改项目名
git push origin maset ,提交本地修改到远程仓库

git状态:(查看，git status)
未跟踪:该文件从来没有拉入git管理中
已跟踪:该文件已经处于git管理中
未修改:第一次clone后，处于git中且没有修改
已修改:在git管理中，且本地做了修改
暂存区:执行了git add命令后的文件状态
提交到本地:执行了git commit命令后，在暂存区中的文件被提交本地库，并新开了一个历史版本

查看详细修改:
git diff : 当前工作区和暂存区的文件比较，如果暂存区没有，则和最新版本比较
git diff --cached/--staged :暂存区和最新版本的比较

忽略某些文件的提交
文件 .gitignore 的格式规范如下：
所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。
可以使用标准的 glob 模式匹配。
匹配模式最后跟反斜杠（/）说明要忽略的是目录。
要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。

删除文件:
git rm ,
git rm --cached,

移动或修改文件
git mv [from_file] [to_file/to_dir]

查看历史记录:
git log,最新的版本再最上面
git log -p -2,每次提交的内容差异，-2表示最近2次更新
git log --stat ,增改行统计
git log --pretty=oneline
git reflog
git log --graph --pretty=oneline --abbrev-commit

撤销操作:
取消已经暂存的文件,git reset HEAD xxx
git reset --hard origin/master  将远程分支强制覆盖本地分支

远程仓库的使用:
查看远程仓库, git remote -v(详情)
添加远程仓库, git remote add [shortname] [url]
从远程仓库抓取数据到本地git库, git fetch shortname,创建了一个新的分支
推送数据到远程仓库, git push origin master,只有在所克隆的服务器上有写权限，或者其他人没有提交数据
查看远程仓库的信息, git remote show [remote-name]
远程仓库的重命名和删除, git remote rename/rm

打标签:
轻量级和含附注两种
显示标签,git tag
设置历史版本标签, git tag -a [历史版本校验和前几个字符或者全部都可以] [说明]
分享标签到远程服务器, git push origin [tagname] ,分享所有，则是git push origin --tags

本地分支使用:(将HEAD指针指向对应分支)
查看分支, git branch
创建分支, git branch [分支名]
切换分支, git checkout [分支名]
创建并切换分支, git checkout -b  [分支名]
合并分支, git merge xxx,在当前分支下,把xxx合并到当前分支
git merge -Xignore-space-change  忽略空白改变

删除合并过的分支, git branch -d [分支名]
查看已经合并(未合并)过的分支, git branch --merged(--no-merged)

分支冲突
git ls-files -u 可以查看共同的祖先版本(1) ，当前分支版本(2)，要合并分支版本(3)
或者使用git show :[1/2/3]:[冲突文件] > 本地文件名
手动修改冲突后，然后使用git merge-file [冲突文件]

Git如何在不提交当前分支内容的情况下切换到其它分支进行操作——git stash 隐藏分支
1、git stash
2、切换到其他分支执行完后
3、git stash list 查找所有的隐藏分支
4、git stash apply [id] ，如stash {0}
5、删除隐藏分支信息，git stash drop [id]

将一个分支上的部分内容合并到当前分支
git checkout --patch xxx_brach file



远程分支使用:
创建并切换分支, git checkout -b  [分支名] [远程名/分支名]
远程分支合并到本地分支, git merge [远程分支名]
删除远程分支, git push [远程名] [本地分支]:[远程分支]，其中设置本地分支为空
	即:git push [远程名] :[远程分支]

分支的变基:不要在公共仓库中同时使用合并和变基操作
git rebase xxx ,将当前分支变基到指定分支xxx的上游去,将当前分支的变化在xxx上重演一遍

git服务器:
协议: 本地传输，SSH协议，Git协议和Http协议
SSH协议, 唯一一个同时支持读写操作的网络协议
	git clone ssh://user@server/project.git
	git remote add origin git@github.com:Username/Your_Repo_Name.git
	缺点:不能通过它对仓库实现匿名访问
Git协议, 提供匿名访问仓库的功能，并且可以允许推送操作，但是没有授权机制

HTTP协议,  易于架设,HTTP 进行推送操作也是可能的


Git工具:
交互式暂存, git add -i

=====================================================
scrapy 安装
使用pip安装scrapy不成功,则:（安装whl之前先安装wheel）
下载scrapy whl文件
下载scrapy依赖库twiste whl文件

1、安装pip install twiste.whl
2、安装scrapy相关依赖包,直接使用pip安装即可
3、安装scrapy
4、测试安装成功：scrapy -h

=====================================================

1、创建项目：scrapy startproject tutorial
	scrapy.cfg:项目配置文件
	tutorial:项目python模块
	tutorial/item.py:项目的item文件
	tutorial/pipelines.py:项目的pipelines文件
	tutorial/settings.py:项目的设置文件
	tutorial/spiders:防止spider代码的模块

2、item定义：保存爬取到的数据的容器
	 模式:field = scrapy.Field()

3、spiders:
	定义一个类集成scrapy.Spider
		name ：必须定义，且唯一
		start_urls:(list类型) 初始要爬取的url列表
		parse():参数为url的响应结果对象response，返回生成的item和进一步处理的url的request对象

4、爬取
进入项目根目录，运行 scrapy crawl name  # 其中name为要爬取的spider的唯一名字


5、获取数据


others:
1、运行scrapy crawl name 报错
提示 ImportError: No module named 'win32api'
需要安装 pip install pypiwin32

2、xpath
/html/body/div/div[2]/div[1]/div[1]
body > div > div:nth-child(2) > div.col-md-8 > div:nth-child(1)

3、git clone 报错fatal: error: RPC failed; result=55, HTTP code = 200
	修改git传送字节限制
	git config --global http.postBuffer 52428800

4、git clone 报错curl 56 OpenSSL SSL_read:SSL_ERROR_sysCALL
	第一步使用env命令保证了忽略证书错误是单次行为，不会成为默认的设置
	1、env命令设置GIT_SSL_NO_VERIFY环境变量为true,并同时调用git clone
	如:env GIT_SSL_NO_VERIFY=true git clone https://<host_name/git/project.git

	第二次，则把忽略证书错误的设置限定在特定的仓库
	2、克隆完毕的仓库中将http.sslVerify设置为false
		git config http.sslVerify "false"

=================================================================================

scrapy-redis + scrapyd + scrapydWeb 分布式爬虫部署及可视化部署

spring + elastic-job 管理任务定时调度机制

spring + oracle + elasticsearch + quarz  java爬虫定时调度


spring 基本层
common包；
	Constants：系统常用变量类
	ItemDic：相关枚举定义
	SessionThreadLocal：会话线程池local

controller包：spring控制器执行者

dao包：springDAO层

service包：springSERVICE层

model包：spring POJO

handler包：统一异常处理


web.xml：先做contextConfiguration --- applicationContext.xml  --- 这里可以定义实体bean(包括包扫描),特性开启（如：注解使能）,自定义配置文件，其他xml文件
		再做dispatcherServlet  --- application-servlet.xml  --- 这里可以定义实体bean，web相关配置
自编写的类，可以使用注解形式进行bean实例化，属性依赖注入

@Configuration 和 @Bean一起使用，前者是类注解，表明内部有bean实例的信息；后者为方法注解，表明该注解下的方法可以实例化bean，该bean的类型是方法返回值的类型，名字是方法名
@Autowired:根据对象类型搜索spring空间中的实体bean并注入到该对象变量中；@Resource:根据对象名字搜索spring空间中的实体bean并注入到该对象变量中
================================================
docker操作：
docker images
docker ps
docker container ls 
docker exec -it [containerid] /bin/bash
退出docker ctrl + p + q
================================================
设计模式7个原则：
1、单一职责原则
2、开闭原则
3、里氏替换原则
4、依赖倒转原则
5、接口隔离原则
6、合成复用原则
7、迪米特法则

1、访问者模式
抽象访问者--具体访问者
抽象元素--具体元素
存储元素对象集合的对象结构
访问者：符合单一职责原则和开闭原则
被访问元素：不符合开不原则，每次添加新的元素，必须在访问者上添加对应的元素操作
这里体现了开闭原则的倾斜性
适合添加访问者的需求，就像流水线上不同工人对统一产品的操作，有的给产品打标签，有的给产品装箱；也像订阅模式，同一份报纸被不同人订阅
主要缺点：
	1、增加新的元素很困难
	2、破坏封装、
	
2、建造者模式 （生成器模式）
指挥者 ---- 安排建造次序，客户端只需要和他交互 ，对于待构建产品的组成部分不多时，可以省略指挥者，直接写到建造者中，但是这样不符合单一职责原则
建造者 ---- 一般有2类方法，部件构建方法，返回结果方法
产品类
建造者模式符合开闭原则，只需要实现抽象建造者即可
如果我们需要创建复杂对象并希望系统具备很好的灵活性和可扩展性可以考虑使用建造者模式
缺点：
建造者模式所创建的产品一般具有较多的共同点，产品之间的差异性很大，就不适用
如果产品的内部变化复杂，需要定义许多具体建造者来实现这种变化，也不适用

3、装饰模式，扩展系统功能
在继承复用过程中，如果需要扩展多个功能，那么进不能使用继承复用方式，因为后续多继承很多语言没法实现
装饰模式可以在不改变一个对象的本身功能的基础上对其添加额外的功能
抽象构建 -- 具体构建和装饰器的父类
装饰类  --- 具体装饰类
缺点：
使用装饰模式进行系统设计时将产生很多小对象，影响系统性能
对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐

4、原型模式，对象的克隆
抽象原型类 -- 具体原型类 -- 可以做为原型对象
浅克隆
深克隆，使用序列化方式

5、职责链模式 ，请求的链式处理
抽象处理者 --- 具体处理者
具体处理事件类
职责链由客户端发起
在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用职责链模式，例如在Web应用开发中创建一个过滤器(Filter)链来对请求数据进行过滤
缺点： 
由于一个请求没有明确的接收者，那么就不能保证它一定会被处理
对于比较长的职责链，系统性能将受到一定影响
如果建链不当，可能会造成循环调用

6、单例模式
只能有一个实例，只能在类内部构造一个实例，该实例供系统全局使用
饿汉模式，类实例变量初始化直接new，因此在该类加载时就已经有了该类的实例
懒汉模式，类不使用时就不初始化，延时加载
Initialization Demand Holder (IoDH)初始化需求保持器技术，将饿汉模式和懒汉模式优点融合，保证了延时加载实例，也保证了线程安全
多例模式可以在单例莫斯的基础上扩展
缺点：
由于单例模式中没有抽象层，因此单例类的扩展有很大的困难
单例类的职责过重，在一定程度上违背了“单一职责原则”
自动垃圾回收机制(java) 会自动回收长时间不用的对象

7、桥接模式（接口模式）， 处理多维变化，抽象耦合(桥),实现解耦
不同维度分离 -- 不同维度的继承等级结构
抽象关联类 --- 桥
抽象桥 -- 与维度接口关联，可以使用维度中的操作
维度接口类 -- 一些维度操作
具体维度类 -- 具体维度操作
一般将某些维度作为抽象部分，其他维度作为实现部分

软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”
在桥接模式中体现了很多面向对象设计原则的思想，包括“单一职责原则”、“开闭原则”、“合成复用原则”、“里氏代换原则”、“依赖倒转原则”等
在处理多维度变化时，和适配器模式联用
桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况

8、适配器模式，不兼容结构的协调
将一个类的接口和另一个类的接口匹配起来，而无须修改原来的适配者接口和抽象目标类接口
在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系
目标抽象类
适配器类 -- 继承目标抽象类，关联适配者类 （这是对象适配器中的方式），要达到的目的就是能够适配到目标抽象类(不能改变)
		 -- 类适配器中的适配器类和适配者类是继承关系，这样不适用于多个适配者，因为许多语言没有多继承
适配者类

双向适配器，用的较少
缺省适配器

9、备忘录模式，撤销功能，软件中的“后悔药”，是软件中的“月光宝盒”
原发器类：要保存内部状态的类，原发器类是一个具体的业务类
备忘录类：存储原发器内部状态的类，需要防止原发器以外的其他对象访问备忘录
负责人类；负责保管备忘录，但不能操作备忘录的内容，可以存储多个备忘录对象，只负责存储对象，而不修改对象
使用场景：
保存一个对象在某一个时刻的全部状态或部分状态
防止外界对象破坏一个对象历史状态的封装性

10、享元模式，对象复用，相当于将最基本的形式存入内部状态中，然后通过外部添加装饰器形态，变为外部状态
内部状态：存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享
外部状态：随环境改变而改变的、不可以共享的状态
抽象享元类 --- 具体享元类，共享 ，定义公共方法  --- 非共享具体享元类，不是共享的
享元工厂 -- 创建和存储享元类，提供一个用于存储享元对象的享元池

单纯享元模式和复合享元模式

享元模式一般和工厂模式或者组合模式一起使用
String类使用的是享元模式

11、解释器模式，自定义语言的实现
文法规则和抽象语法树，定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码
环境类(上下文类)：存储解释器之外的一些全局信息
抽象语法树类:声明了抽象的解释操作
终结表达式类：实现了与文法中的终结符相关联的解释操作
非终结表达式类；实现了文法中非终结符的解释操作